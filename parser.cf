entrypoints Program, Stm, Exp;



-- a program is a sequence of definition
Prog. Program ::= [External_declaration];



-- there can be one or nonempty list of definitions
separator External_declaration "";



-- definitions can contain functions and also declarations
Afunc.  External_declaration ::= Function_def ;
Global. External_declaration ::= Dec ;
Qconstant. External_declaration ::= Qcons ;



-- defining grammar for a function
NewFunc. Function_def ::= Declaration_specifier Declarator Body;



-- defining grammar for declarations
Declarators. Dec ::= Declaration_specifier [Init_declarator] ";" ;
separator Dec "";


-- defining grammar for declarations
NewCons. Qcons ::= Qcons_specifier  ";" ;
QCons. Qcons_specifier ::= Cons_specifier QualifiedConstant ;-- using



TypeOne. Declaration_specifier ::= Type_specifier ;
TypeTwo. Declaration_specifier ::= Declaration_prefix Type_specifier ;
TypeThree. Declaration_specifier ::= Declaration_specifier Declaration_postfix;

DprefixOne. Declaration_prefix ::= "typedef";
DprefixTwo. Declaration_prefix ::= "const";

DpostfixOne. Declaration_postfix ::= "&";

Basictype. Type_specifier ::= BasicType ;
Constype. Type_specifier ::= QualconsType ;



(:[]).   [Init_declarator] ::= Init_declarator ;
(:). [Init_declarator] ::= Init_declarator "," [Init_declarator] ;



OnlyDecl.  Init_declarator ::= Declarator ;
InitDecl. Init_declarator ::= Declarator "=" Initializer;


BasicTypeOne. BasicType ::= BuiltInType ;
BasicTypeTwo. BasicType ::= Ident ; --reduce conflicts


Tvoid.        BuiltInType ::= "void";
Tbool.        BuiltInType ::= "bool";
Tchar.        BuiltInType ::= "char";
Tshort.       BuiltInType ::= "short";
Tint.         BuiltInType ::= "int";
Tlong.        BuiltInType ::= "long";
Tfloat.       BuiltInType ::= "float";
Tdouble.      BuiltInType ::= "double";
Tsigned.      BuiltInType ::= "signed";
Tunsigned.    BuiltInType ::= "unsigned";
-- dont forget to add struct declarations



Qconstype.  QualconsType ::= QualifiedConstant; --reduce conflicts



Cusing.     Cons_specifier ::= "using";



NoPointer. Declarator ::= Direct_declarator ;
Name. Direct_declarator ::= Ident ;
NewFuncDec. Direct_declarator ::= Direct_declarator "(" Parameter_type ")" ;
OldFuncDec. Direct_declarator ::= Direct_declarator "(" ")" ;



AllSpec.  Parameter_type ::= Parameter_declarations ;
More. Parameter_type ::= Parameter_declarations "," "..." ;

ParamDec.     Parameter_declarations ::= Parameter_declaration ;                   
MoreParamDec. Parameter_declarations ::= Parameter_declarations "," Parameter_declaration ;

OnlyType.      Parameter_declaration ::= Declaration_specifier ;
TypeAndParam. Parameter_declaration ::= Declaration_specifier Declarator ;



InitExpr. Initializer ::= Exp2 ;



ExprS. Stm ::= Expression_stm ;
LV. Stm ::= "{" [LVarStatement] "}";
SelS. Stm ::= Selection_stm ;
IterS. Stm ::= Iter_stm ;
JumpS. Stm ::= Jump_stm ;



-- qualified constant
-- implemented as nonempty lists separated by ::
-- elements of the list are identifiers and template instatiation
-- i, c::i, c::c::i

QualConstant. QualifiedConstant ::= [Constants] ;

(:[]).   [Constants] ::= Constants ;
(:). [Constants] ::= Constants "::" [Constants] ;

ConIdent. Constants ::= Ident; --reduce conflicts
ConTemplate. Constants ::= TemplateInstatiation;

TemplateIns. TemplateInstatiation ::= Ident "<" Parameter_type ">" ;



-- variable declarations and statements
LVar.		LVarStatement ::= Declaration_specifier [Init_declarator] ";" ;
Statem.		LVarStatement ::= Stm;
separator 	LVarStatement "";

-- need to be more sophisticated
LFor.		ForStatement ::= Declaration_specifier [Init_declarator] ;
StateFor.	ForStatement ::= Exp;
separator 	ForStatement ";";

BodyTwo.	Body ::= "{" [LVarStatement] "}";



SexprOne. Expression_stm ::= ";" ;
SexprTwo. Expression_stm ::= Exp ";" ;



SselOne. Selection_stm ::= "if" "(" Exp ")" Stm ;
SselTwo. Selection_stm ::= "if" "(" Exp ")" Stm "else" Stm ;



SiterOne. Iter_stm ::= "while" "(" Exp ")" Stm ;
SiterTwo. Iter_stm ::= "for" "(" [ForStatement] ")" Stm ;



SjumpFive. Jump_stm ::= "return" Exp ";" ;
--SjumpSix. Jump_stm ::= "throw" Exp ";" ;



(:[]).   [Stm] ::= Stm ;
(:). [Stm] ::= Stm [Stm];



-- qualified identifier
--separator nonempty Ident ".";

Ethrow.		Exp ::= "throw" Exp2;
Econdition.  Exp2  ::= Exp3 "?" Exp ":" Exp2;
Eassign.     Exp2  ::= Exp13 Assignment_op Exp2;
Elor.        Exp3  ::= Exp3 "||" Exp4;
Eland.       Exp4  ::= Exp4 "&&" Exp5;

Ebitor.      Exp5  ::= Exp5 "|" Exp6;
Ebitexor.    Exp6  ::= Exp6 "^" Exp7;
Ebitand.     Exp7  ::= Exp7 "&" Exp8;
Eeq.         Exp8  ::= Exp8 "==" Exp9;
Eneq.        Exp8  ::= Exp8 "!=" Exp9;

Elthan.      Exp9 ::= Exp9 "<" Exp10;
Egrthan.     Exp9 ::= Exp9 ">" Exp10;
Ele.         Exp9 ::= Exp9 "<=" Exp10;
Ege.         Exp9 ::= Exp9 ">=" Exp10;

Eleft.       Exp10 ::= Exp10 "<<" Exp11;
Eright.      Exp10 ::= Exp10 ">>" Exp11;

Eplus.       Exp11 ::= Exp11 "+" Exp12;
Eminus.      Exp11 ::= Exp11 "-" Exp12;

Etimes.      Exp12 ::= Exp12 "*" Exp13;
Ediv.        Exp12 ::= Exp12 "/" Exp13;
Emod. 		 Exp12 ::= Exp12 "%" Exp13;

Epreinc.     Exp13 ::= "++" Exp13;
Epredec.     Exp13 ::= "--" Exp13;
Epointer.    Exp13 ::= "*" Exp13;
Enot.        Exp13 ::= "!" Exp13;

Epostinc.    Exp14 ::= Exp14 "++";
Epostdec.    Exp14 ::= Exp14 "--";
Epoint.      Exp14 ::= Exp14 "." Exp15;
Eselect.     Exp14 ::= Exp14 "->" Exp15;


Emth.		 Exp15 ::= Exp15 Args;
Earray.      Exp15 ::= Exp15 "[" Exp "]";
--Efld.		 Exp15 ::= FieldAcc;
Equalconst.  Exp16 ::= QualifiedConstant;
Econst.      Exp16 ::= Constant;
Estring.     Exp16 ::= String;

--Evar.        Exp16 ::= Ident;



ArgsOne.	Args ::= "(" ")";
ArgsTwo.	Args ::= "(" [Exp2] ")";

coercions Exp 16;



token JChar '\'' ((char - ["'\\"]) | ('\\' ["'\\ntr"])) '\'';

token JDouble (((digit+ '.')|('.' digit+))(('e'|'E') ('-')? digit+)?)|
              (digit+ ('e'|'E') ('-')? digit+)|(digit+ '.' digit+ 'E' ('-')? digit+);

token JFloat (((digit+ '.' digit+)|(digit+ '.')|('.' digit+))(('e'|'E')('-')? digit+)?
                               ('f'|'F'))|((digit+ ('e'|'E')('-')? digit+)('f'|'F'));



Efloat.        Constant ::= Double;
Echar.         Constant ::= JChar;
Ecdouble.      Constant ::= JDouble;
Ecfloat.       Constant ::= JFloat;
Eint. 		   Constant ::= Integer;

separator Exp2 "," ;

Assign.       Assignment_op ::= "=" ;
AssignMul.    Assignment_op ::= "*=" ;
AssignDiv.    Assignment_op ::= "/=" ;
AssignMod.    Assignment_op ::= "%=" ;
AssignAdd.    Assignment_op ::= "+=" ;
AssignSub.    Assignment_op ::= "-=" ;
AssignLeft.   Assignment_op ::= "<<=" ;
AssignRight.  Assignment_op ::= ">>=" ;
AssignAnd.    Assignment_op ::= "&=" ;
AssignXor.    Assignment_op ::= "^=" ;
AssignOr. Assignment_op ::= "|=" ;

comment "/*" "*/" ;
comment "//";
comment "#";


-- bugs to fix
-- new line string


{-

(ExprS (SexprTwo (Emth (Mmth [Ident "homework",Ident "push_back"] (ArgsTwo [Evar [Ident "x"]])))))))


ret[entry[0]].push_back(Rule(entry.begin() + 1, entry.end()));

Statem (ExprS (SexprTwo (Emth (Mmth [Ident "sort"] (ArgsTwo [Emth (Mmth [Ident "homework",Ident "begin"] ArgsOne),Emth (Mmth [Ident "homework",Ident "end"] ArgsOne)])))))




(Exps (Emth (Mmth1 (CNPfld (Ffvar (Cnp (CNParr (Aarr [Ident "ret"] (Earr (Aarr [Ident "entry"] (Econst (Eoctal (Octal "0")))))))) (Ident "push_back"))) (Args [Emth (Mmth [Ident "Rule"] (Args [Eplus (Emth (Mmth [Ident "entry",Ident "begin"] (Args []))) (Econst (Eint 1)),Emth (Mmth [Ident "entry",Ident "end"] (Args []))
-}